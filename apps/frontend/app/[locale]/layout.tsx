import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import '../globals.css';
import { ReactNode } from 'react';
import { languages } from '@/app/i18n/settings';
import { notFound } from 'next/navigation';
import { getTranslation } from '@/app/i18n';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

interface LayoutProps {
  children: ReactNode;
  params: Promise<{ locale: string }>;
}

export default async function RootLayout({
  children,
  params,
}: Readonly<LayoutProps>) {
  const p = await params;

  if (!languages.includes(p.locale as any)) {
    notFound();
  }
  return (
    <html lang={p.locale} suppressHydrationWarning>
      <head>
        <NextChatSDKBootstrap
          baseUrl={process.env.NEXTJS_URL || 'http://localhost:8000'}
        />
      </head>
      <body
        suppressHydrationWarning
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

function NextChatSDKBootstrap({ baseUrl }: { baseUrl: string }) {
  return (
    <>
      <base href={baseUrl}></base>
      <script>{`window.innerBaseUrl = ${JSON.stringify(baseUrl)}`}</script>
      <script
        suppressHydrationWarning
      >{`window.__isChatGptApp = typeof window.openai !== "undefined";`}</script>
      <script suppressHydrationWarning>
        {'(' +
          (() => {
            const baseUrl = window.innerBaseUrl;
            const isChatGptApp = window.__isChatGptApp;
            const isInIframe = window.self !== window.top;

            // ChatGPT 앱 환경에서만 base 태그 추가
            if (isChatGptApp || isInIframe) {
              const baseTag = document.createElement('base');
              baseTag.href = baseUrl;
              document.head.prepend(baseTag);
            }

            const htmlElement = document.documentElement;
            const observer = new MutationObserver((mutations) => {
              mutations.forEach((mutation) => {
                if (
                  mutation.type === 'attributes' &&
                  mutation.target === htmlElement
                ) {
                  const attrName = mutation.attributeName;
                  if (attrName && attrName !== 'suppresshydrationwarning') {
                    htmlElement.removeAttribute(attrName);
                  }
                }
              });
            });
            observer.observe(htmlElement, {
              attributes: true,
              attributeOldValue: true,
            });

            // ChatGPT 앱 환경에서만 history 오버라이드 적용
            if (isChatGptApp) {
              const originalReplaceState = history.replaceState;
              history.replaceState = (s, unused, url) => {
                const u = new URL(url ?? '', window.location.href);
                const href = u.pathname + u.search + u.hash;
                originalReplaceState.call(history, s, unused, href);
              };

              const originalPushState = history.pushState;
              history.pushState = (s, unused, url) => {
                const u = new URL(url ?? '', window.location.href);
                const href = u.pathname + u.search + u.hash;
                originalPushState.call(history, s, unused, href);
              };
            }

            const appOrigin = new URL(baseUrl).origin;

            window.addEventListener(
              'click',
              (e) => {
                const a = (e?.target as HTMLElement)?.closest('a');
                if (!a || !a.href) return;
                const url = new URL(a.href, window.location.href);
                if (
                  url.origin !== window.location.origin &&
                  url.origin != appOrigin
                ) {
                  try {
                    if (window.openai) {
                      window.openai?.openExternal({ href: a.href });
                      e.preventDefault();
                    }
                  } catch {
                    console.warn(
                      'openExternal failed, likely not in OpenAI client',
                    );
                  }
                }
              },
              true,
            );

            if (isInIframe && window.location.origin !== appOrigin) {
              const originalFetch = window.fetch;

              window.fetch = (input: URL | RequestInfo, init?: RequestInit) => {
                let url: URL;
                if (typeof input === 'string' || input instanceof URL) {
                  url = new URL(input, window.location.href);
                } else {
                  url = new URL(input.url, window.location.href);
                }

                if (url.origin === appOrigin) {
                  if (typeof input === 'string' || input instanceof URL) {
                    input = url.toString();
                  } else {
                    input = new Request(url.toString(), input);
                  }

                  return originalFetch.call(window, input, {
                    ...init,
                    mode: 'cors',
                  });
                }

                if (url.origin === window.location.origin) {
                  const newUrl = new URL(baseUrl);
                  newUrl.pathname = url.pathname;
                  newUrl.search = url.search;
                  newUrl.hash = url.hash;
                  url = newUrl;

                  if (typeof input === 'string' || input instanceof URL) {
                    input = url.toString();
                  } else {
                    input = new Request(url.toString(), input);
                  }

                  return originalFetch.call(window, input, {
                    ...init,
                    mode: 'cors',
                  });
                }

                return originalFetch.call(window, input, init);
              };
            }
          }).toString() +
          ')()'}
      </script>
    </>
  );
}
